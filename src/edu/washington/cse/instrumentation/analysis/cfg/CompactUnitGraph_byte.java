package edu.washington.cse.instrumentation.analysis.cfg;

/*
 * THIS FILE IS AUTOMATICALLY GENERATED
 */

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;

import soot.Unit;
import soot.toolkits.graph.DirectedGraph;
import soot.toolkits.graph.UnitGraph;
public class CompactUnitGraph_byte extends UnitGraph implements DirectedGraph<Unit> {
	private final byte[] succ_ptr;
	private final byte[] prev_ptr;

	private byte head_ptrs;
	private byte tail_ptrs;

	private final int sz;
	private final Unit[] units;

	public CompactUnitGraph_byte(final DirectedGraph<Unit> in) {
		super(((UnitGraph)in).getBody());
		this.sz = in.size();
		this.succ_ptr = new byte[this.sz];
		this.prev_ptr = new byte[this.sz];
		this.units = new Unit[this.sz];

		head_ptrs = 0;
		tail_ptrs = 0;

		for(final Unit u : in) {
			int index = findOrAllocate(u);
			if(in.getHeads().contains(u)) {
				head_ptrs = (byte)(head_ptrs | (((byte)1) << index));
			}

			if(in.getTails().contains(u)) {
				tail_ptrs = (byte)(tail_ptrs | (((byte)1) << index));
			}

			this.units[index] = u;
			{
				byte prev_accum = 0;
				for(Unit pr : in.getPredsOf(u)) {
					prev_accum = (byte)(prev_accum | (((byte)1) << (findOrAllocate(pr))));
				}
				prev_ptr[index] = prev_accum;
			}
			{
				byte succ_accum = 0;
				for(Unit sc : in.getSuccsOf(u)) {
					succ_accum = (byte)(succ_accum | (((byte)1) << (findOrAllocate(sc))));
				}
				succ_ptr[index] = succ_accum;
			}
		}
	}

	@Override
	public List<Unit> getHeads() {
		List<Unit> toReturn = new ArrayList<>();
		for(int i = 0; i < 8; i++) {
			if(((head_ptrs >> i) & 1) == 1) {
				toReturn.add(units[i]);
			}
		}
		return toReturn;
	}

	@Override
	public List<Unit> getTails() {
		List<Unit> toReturn = new ArrayList<>();
		for(int i = 0; i < 8; i++) {
			if(((tail_ptrs >> i) & 1) == 1) {
				toReturn.add(units[i]);
			}
		}
		return toReturn;
	}
	@Override
   public List<Unit> getPredsOf(final Unit s) {
		int index = find(s);
		if(prev_ptr[index] == 0) {
			return Collections.<Unit>emptyList();
		}
		ArrayList<Unit> toReturn = new ArrayList<>();
		byte prev = prev_ptr[index];
		for(int i = 0; i < 8; i++) {
			if(((prev >> i) & 1) == 1) {
				toReturn.add(units[i]);
			}
		}
		return toReturn;
	}
	@Override
	public List<Unit> getSuccsOf(final Unit s) { 
		int index = find(s);
		if(succ_ptr[index] == 0) {
			return Collections.<Unit>emptyList();
		}
		ArrayList<Unit> toReturn = new ArrayList<>();
		byte succ = succ_ptr[index];
		for(int i = 0; i < 8; i++) {
			if(((succ >> i) & 1) == 1) {
				toReturn.add(units[i]);
			}
		}
		return toReturn;
	}

	@Override
	public int size() { return this.sz; }
	@Override
	public Iterator<Unit> iterator() {
		return new Iterator<Unit>() {
			int it = 0;
			public void remove() {
				throw new UnsupportedOperationException();
			}
			public boolean hasNext() {
				return it < units.length;
			}
			public Unit next() {
				return units[it++];
			}
		};
	}

	private int findOrAllocate(Unit u) {
		int probe = u.hashCode() % units.length;
		int it = 0;
		while(it < this.sz) {
			int ind = (it + probe) % units.length;
			if(units[ind] == null) {
				units[ind] = u;
				return ind;
			} else if(units[ind] == u) {
				return ind;
			}
			it++;
		}
		throw new RuntimeException("No space");
	}
	private int find(Unit u) {
		int probe = u.hashCode() % units.length;
		int it = 0;
		while(it < this.sz) {
			int ind = (it + probe) % units.length;
			if(units[ind] == u) {
				return ind;
			}
			it++;
		}
		throw new RuntimeException("Not found");
	}
}

